
theory Lists

  use list.List
  use int.Int


  function (++) (l1 l2: list 'a) : list 'a =
  match l1 with
    | Nil -> l2
    | Cons x1 r1 -> Cons x1 (r1 ++ l2)
  end


  lemma app_nil:
    forall l :list 'a. l++Nil = l



  function length (l: list 'a) : int =
    match l with
    | Nil      -> 0
    | Cons _ r -> 1 + length r
    end


  lemma aux_length: 
    forall x: 'a, l :list 'a. length (Cons x l) = 1 + (length l)

  lemma app_length :
    forall l1 l2 :list 'a. length (l1 ++ l2) = length l1 + length l2

   

  function snoc (x:'a) (l:list 'a) : list 'a =
    match l with
      | Nil -> Cons x Nil
      | Cons h t -> Cons h (snoc x t)
    end

  lemma snoc_len : forall x:'a,  l:list 'a. length (snoc x l) = 1 + (length l)

  lemma snoc_app : forall x:'a,  l:list 'a.  snoc x l =  l ++ (Cons x Nil)


  (* list membership function *)
  use  list.Mem

  lemma mem_app: forall x :'a, l1 l2 :list 'a. 
                mem x (l1 ++ l2) -> mem x l1 \/ mem x l2




  function reverse (l: list 'a) : list 'a = match l with
    | Nil      -> Nil
    | Cons x r -> reverse r ++ Cons x Nil
  end

  lemma rev_aux : forall x:'a, l: list 'a.  reverse (l ++ (Cons x Nil)) = Cons x (reverse l)
    

  lemma rev_rev : forall l: list 'a. reverse (reverse l) = l



  inductive last 'a (list 'a) =
  | Last_one : forall x: 'a. last x (Cons x Nil)
  | Last_two : forall x y: 'a, l: list 'a. last x l -> last x (Cons y l)



  lemma last_nil : forall x:'a. not (last x Nil)


  function lastf (l: list int) : int = match l with
    | Nil        -> 0
    | Cons x Nil -> x
    | Cons x t   -> lastf t
  end

  lemma lastf_aux : forall x:int, t: list int.
                    t<>Nil -> lastf (Cons x t) = lastf t

  lemma lastf1 : forall x:int, l: list int.
                 l<>Nil -> last (lastf l) l

  lemma lastf2 : forall x:int, l: list int.
                 last x l -> x = lastf (Cons x l)


  (* lemma check_list : forall l: list 'a. l=Nil \/ l<>Nil *)



end

