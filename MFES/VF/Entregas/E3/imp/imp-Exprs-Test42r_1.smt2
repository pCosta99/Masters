;; produced by cvc4_16.drv ;;
(set-logic AUFBVFPDTNIRA)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun string () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

;; bool_inversion
  (assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

(declare-fun tuple01 () ty)

(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
  (assert (forall ((u tuple0)) (= u Tuple0)))

(declare-fun infix_mngt (ty ty) ty)

(declare-sort ident 0)

(declare-fun ident1 () ty)

(declare-fun infix_at (ty ty uni uni) uni)

;; infix @_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

(declare-fun set (ty ty uni uni uni) uni)

;; set_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (infix_mngt a b)
  (set b a x x1 x2)))))

(declare-fun const1 (ty ty uni) uni)

;; const_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni)) (sort (infix_mngt a b) (const1 b a x)))))

(declare-fun const2 (Int) (Array ident Int))

;; const'def
  (assert
  (forall ((v Int)) (forall ((us ident)) (= (select (const2 v) us) v))))

;; const'def
  (assert
  (forall ((a ty) (b ty))
  (forall ((v uni))
  (=> (sort b v) (forall ((us uni)) (= (infix_at b a (const1 b a v) us) v))))))

;; CompatOrderMult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

(declare-fun mk_ident (Int) ident)

(declare-sort operator 0)

(declare-fun operator1 () ty)

(declare-fun Oplus () operator)

(declare-fun Ominus () operator)

(declare-fun Omult () operator)

(declare-fun match_operator (ty operator uni uni uni) uni)

;; match_operator_sort
  (assert
  (forall ((a ty))
  (forall ((x operator) (x1 uni) (x2 uni) (x3 uni)) (sort a
  (match_operator a x x1 x2 x3)))))

;; match_operator_Oplus
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni))
  (=> (sort a z) (= (match_operator a Oplus z z1 z2) z)))))

;; match_operator_Ominus
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni))
  (=> (sort a z1) (= (match_operator a Ominus z z1 z2) z1)))))

;; match_operator_Omult
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni))
  (=> (sort a z2) (= (match_operator a Omult z z1 z2) z2)))))

(declare-fun index_operator (operator) Int)

;; index_operator_Oplus
  (assert (= (index_operator Oplus) 0))

;; index_operator_Ominus
  (assert (= (index_operator Ominus) 1))

;; index_operator_Omult
  (assert (= (index_operator Omult) 2))

;; operator_inversion
  (assert
  (forall ((u operator)) (or (or (= u Oplus) (= u Ominus)) (= u Omult))))

(declare-sort expr 0)

(declare-fun expr1 () ty)

(declare-fun Econst (Int) expr)

(declare-fun Evar (ident) expr)

(declare-fun Ebin (expr operator expr) expr)

(declare-fun match_expr (ty expr uni uni uni) uni)

;; match_expr_sort
  (assert
  (forall ((a ty))
  (forall ((x expr) (x1 uni) (x2 uni) (x3 uni)) (sort a
  (match_expr a x x1 x2 x3)))))

;; match_expr_Econst
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni) (u Int))
  (=> (sort a z) (= (match_expr a (Econst u) z z1 z2) z)))))

;; match_expr_Evar
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni) (u ident))
  (=> (sort a z1) (= (match_expr a (Evar u) z z1 z2) z1)))))

;; match_expr_Ebin
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni) (u expr) (u1 operator) (u2 expr))
  (=> (sort a z2) (= (match_expr a (Ebin u u1 u2) z z1 z2) z2)))))

(declare-fun index_expr (expr) Int)

;; index_expr_Econst
  (assert
  (forall ((u Int)) (! (= (index_expr (Econst u)) 0) :pattern ((Econst u)) )))

;; index_expr_Evar
  (assert
  (forall ((u ident)) (! (= (index_expr (Evar u)) 1) :pattern ((Evar u)) )))

;; index_expr_Ebin
  (assert
  (forall ((u expr) (u1 operator) (u2 expr))
  (! (= (index_expr (Ebin u u1 u2)) 2) :pattern ((Ebin u u1 u2)) )))

(declare-fun Econst_proj_1 (expr) Int)

;; Econst_proj_1'def
  (assert (forall ((u Int)) (= (Econst_proj_1 (Econst u)) u)))

(declare-fun Evar_proj_1 (expr) ident)

;; Evar_proj_1'def
  (assert (forall ((u ident)) (= (Evar_proj_1 (Evar u)) u)))

(declare-fun Ebin_proj_1 (expr) expr)

;; Ebin_proj_1'def
  (assert
  (forall ((u expr) (u1 operator) (u2 expr))
  (= (Ebin_proj_1 (Ebin u u1 u2)) u)))

(declare-fun Ebin_proj_2 (expr) operator)

;; Ebin_proj_2'def
  (assert
  (forall ((u expr) (u1 operator) (u2 expr))
  (= (Ebin_proj_2 (Ebin u u1 u2)) u1)))

(declare-fun Ebin_proj_3 (expr) expr)

;; Ebin_proj_3'def
  (assert
  (forall ((u expr) (u1 operator) (u2 expr))
  (= (Ebin_proj_3 (Ebin u u1 u2)) u2)))

;; expr_inversion
  (assert
  (forall ((u expr))
  (or (or (= u (Econst (Econst_proj_1 u))) (= u (Evar (Evar_proj_1 u))))
  (= u (Ebin (Ebin_proj_1 u) (Ebin_proj_2 u) (Ebin_proj_3 u))))))

(declare-fun eval_expr ((Array ident Int) expr) Int)

;; eval_expr'def
  (assert
  (forall ((s (Array ident Int)))
  (and
  (and (forall ((i1 Int)) (= (eval_expr s (Econst i1)) i1))
  (forall ((i2 ident)) (= (eval_expr s (Evar i2)) (select s i2))))
  (forall ((e1 expr) (op operator) (e2 expr))
  (let ((e (Ebin e1 op e2)))
  (and
  (and
  (=> (= op Oplus) (= (eval_expr s e) (+ (eval_expr s e1) (eval_expr s e2))))
  (=> (= op Ominus)
  (= (eval_expr s e) (- (eval_expr s e1) (eval_expr s e2)))))
  (=> (= op Omult) (= (eval_expr s e) (* (eval_expr s e1) (eval_expr s e2))))))))))

(declare-fun eval_expr_rel ((Array ident Int) expr (Array ident Int)
  Int) Bool)

;; econst
  (assert
  (forall ((n Int) (s (Array ident Int))) (eval_expr_rel s (Econst n) s n)))

;; evar
  (assert
  (forall ((n ident) (s (Array ident Int))) (eval_expr_rel s (Evar n) s
  (select s n))))

;; ebinPlus
  (assert
  (forall ((e1 expr) (e2 expr) (n1 Int) (n2 Int) (s (Array ident Int)))
  (=> (and (eval_expr_rel s e1 s n1) (eval_expr_rel s e2 s n2))
  (eval_expr_rel s (Ebin e1 Oplus e2) s (+ n1 n2)))))

;; ebinMinus
  (assert
  (forall ((e1 expr) (e2 expr) (n1 Int) (n2 Int) (s (Array ident Int)))
  (=> (and (eval_expr_rel s e1 s n1) (eval_expr_rel s e2 s n2))
  (eval_expr_rel s (Ebin e1 Ominus e2) s (- n1 n2)))))

;; ebinMult
  (assert
  (forall ((e1 expr) (e2 expr) (n1 Int) (n2 Int) (s (Array ident Int)))
  (=> (and (eval_expr_rel s e1 s n1) (eval_expr_rel s e2 s n2))
  (eval_expr_rel s (Ebin e1 Omult e2) s (* n1 n2)))))

;; eval_expr_rel_inversion
  (assert
  (forall ((z (Array ident Int)) (z1 expr) (z2 (Array ident Int)) (z3 Int))
  (=> (eval_expr_rel z z1 z2 z3)
  (or
  (or
  (or
  (or (and (= z1 (Econst z3)) (= z2 z))
  (exists ((n ident))
  (and (and (= z1 (Evar n)) (= z2 z)) (= z3 (select z n)))))
  (exists ((e1 expr) (e2 expr) (n1 Int) (n2 Int))
  (and (and (eval_expr_rel z e1 z n1) (eval_expr_rel z e2 z n2))
  (and (and (= z1 (Ebin e1 Oplus e2)) (= z2 z)) (= z3 (+ n1 n2))))))
  (exists ((e1 expr) (e2 expr) (n1 Int) (n2 Int))
  (and (and (eval_expr_rel z e1 z n1) (eval_expr_rel z e2 z n2))
  (and (and (= z1 (Ebin e1 Ominus e2)) (= z2 z)) (= z3 (- n1 n2))))))
  (exists ((e1 expr) (e2 expr) (n1 Int) (n2 Int))
  (and (and (eval_expr_rel z e1 z n1) (eval_expr_rel z e2 z n2))
  (and (and (= z1 (Ebin e1 Omult e2)) (= z2 z)) (= z3 (* n1 n2)))))))))

(assert
;; Test42r
 ;; File "/home/pcosta/Desktop/Masters/MFES/VF/Entregas/E3/imp.why", line 71, characters 7-14
  (not
  (let ((x (mk_ident 0)))
  (let ((s (store (const2 0) x 42))) (eval_expr_rel s (Evar x) s 42)))))
(check-sat)
